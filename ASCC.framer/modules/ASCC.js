// Generated by CoffeeScript 1.9.1
var _calculateDistance, _chooseGesture, _deltas, _drag, _updateVelocity, distance, timeOut;

_deltas = [];

timeOut = 100;

distance = 0;

exports.gesture = null;

exports.minDistance = 110;

exports.minGestureVelocity = 1.786;

exports.appSwitcher = function(calcbot, spotify, alto, recents, icons, calcbotIcon, curve) {
  calcbot.draggable.enabled = false;
  calcbot.on(Events.Click, function() {
    calcbot.animateStop();
    spotify.animateStop();
    alto.animateStop();
    icons.animateStop();
    recents.animateStop();
    calcbot.states["switch"]("app", {
      curve: curve
    });
    spotify.states["switch"]("app", {
      curve: curve
    });
    alto.states["switch"]("app", {
      curve: curve
    });
    icons.states["switch"]("app", {
      curve: curve
    });
    recents.states["switch"]("app");
    calcbot.draggable.enabled = true;
  });
  return calcbotIcon.on(Events.Click, function() {
    calcbot.animateStop();
    spotify.animateStop();
    alto.animateStop();
    icons.animateStop();
    recents.animateStop();
    calcbot.states["switch"]("app", {
      curve: curve
    });
    spotify.states["switch"]("app", {
      curve: curve
    });
    alto.states["switch"]("app", {
      curve: curve
    });
    icons.states["switch"]("app", {
      curve: curve
    });
    recents.states["switch"]("app");
    calcbot.draggable.enabled = true;
  });
};

exports.calculateVelocity = function(event, calcbot, controlCenter, recents, originY) {
  var curr, prev, time, timeSinceLastMove, velocity;
  if (_deltas.length < 2) {
    return 0;
  }
  curr = _deltas.slice(-2, -1)[0];
  prev = _deltas.slice(-1)[0];
  time = curr.t - prev.t;
  velocity = ((curr.y - prev.y) / time) * -1;
  timeSinceLastMove = new Date().getTime() - prev.t;
  if (timeSinceLastMove > timeOut) {
    return 0;
  }
  if (isNaN(velocity) === true) {
    return 0;
  }
  calcbot.emit("calculateDistance", event, calcbot, recents, originY);
  calcbot.emit("chooseGesture", velocity, calcbot, controlCenter);
  return velocity;
};

exports.makeDraggable = function(layer, speedX, speedY) {
  layer.draggable.enabled = true;
  layer.draggable.speedX = speedX;
  return layer.draggable.speedY = speedY;
};

exports.removeListeners = function() {
  var velocity;
  document.removeEventListener(Events.TouchMove, _updateVelocity);
  exports.gesture = null;
  _deltas = [];
  return velocity = 0;
};

exports.addListeners = function(calcbot) {
  document.addEventListener(Events.TouchMove, _updateVelocity);
  calcbot.once("chooseGesture", _chooseGesture);
  return calcbot.on("calculateDistance", _calculateDistance);
};

_calculateDistance = function(event, calcbot, recents, originY) {
  distance = originY - event.pageY;
  if (exports.gesture === "Drag") {
    return _drag(distance, calcbot, recents);
  } else {

  }
};

_drag = function(distance, calcbot, recents) {
  calcbot.scale = Utils.modulate(distance, [0, 657], [1, .4867], true);
  return recents.opacity = Utils.modulate(calcbot.scale, [.70, .4867], [0, 1], true);
};

_chooseGesture = function(velocity, calcbot, controlCenter) {
  if (velocity < exports.minGestureVelocity && distance < exports.minDistance) {
    return exports.gesture = "Drag";
  } else {
    calcbot.draggable.enabled = false;
    return controlCenter.states["switch"]("open", {
      curve: "spring(550, 25, 0)"
    });
  }
};

_updateVelocity = function(event) {
  var updatedDelta;
  updatedDelta = {
    y: event.pageY,
    t: event.timeStamp
  };
  return _deltas.push(updatedDelta);
};
